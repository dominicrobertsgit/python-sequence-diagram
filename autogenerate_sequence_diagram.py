import sys
import ast
import os
import inspect
import random
import string
import wrapt

THIS_FILES_DIRECTORY_PATH = os.path.dirname(os.path.abspath(__file__))

class AutogeneratedSequenceDiagram:
  def __init__(self, top_file_name, top_level_directory_path):
    self._top_file_name = top_file_name
    self._top_level_directory_path = top_level_directory_path
    
  def __enter__(self):
    self._sequence_diagram = _UmletSequenceDiagram()
    
    for root_directory_path, directory_list, file_list in os.walk(self._top_level_directory_path):

      if ".git" in root_directory_path:
          continue
      
      python_source_file_list = [x for x in file_list if x[-(len(".py")):] == ".py" and \
                                                         x != "__init__.py" and \
                                                         "autogenerate_sequence_diagram.py" not in x]
      for file_name in python_source_file_list:
        file_path = os.path.join(root_directory_path, file_name)
        #print(file_path)
        self._add_lazy_post_import_hook(file_path=file_path, hook_called_per_function_call=self._hook)
  
  def _add_lazy_post_import_hook(self, file_path, hook_called_per_function_call):
    #print(file_path)
    
    def _add_per_function_hook_for_module(target_module):
      with open(file_path, "rt") as file:
        ast_tree = ast.parse(file.read(), filename=file_path)
      
      top_level_ast_function_list = (f for f in ast_tree.body if isinstance(f, ast.FunctionDef))
      for ast_function in top_level_ast_function_list:
        wrapt.wrap_function_wrapper(target_module, ast_function.name, hook_called_per_function_call)
      
      top_level_ast_class_list = (f for f in ast_tree.body if isinstance(f, ast.ClassDef))
      #print(list(top_level_ast_class_list))
      for ast_class in top_level_ast_class_list:
        
        ast_class_function_list = (f for f in ast_class.body if isinstance(f, ast.FunctionDef))
        for ast_class_function in ast_class_function_list:
          actual_class = getattr(target_module, ast_class.name)
          wrapt.wrap_function_wrapper(actual_class, ast_class_function.name, hook_called_per_function_call)
    
    target_module_name = os.path.basename(file_path)[:-(len(".py"))]
      
    relative_path = file_path.split(self._top_level_directory_path)[1]
    modules_above_target_module_string = relative_path.split(target_module_name)[0]
    modules_above_target_module = [x for x in modules_above_target_module_string.split("\\") if len(x) > 0]
    if len(modules_above_target_module) > 0:
      target_module_path = ".".join(modules_above_target_module) + "." + target_module_name
    else:
      target_module_path = target_module_name
    #print("\t" + target_module_path)
    wrapt.register_post_import_hook(_add_per_function_hook_for_module, target_module_path)

  def _hook(self, actual_function, instance, args, kwargs):
      #print(inspect.stack())
      stack_data = inspect.getframeinfo(inspect.stack()[2][0])
      calling_call_metadata = {
        "function":   stack_data.function,
        "file_path":  stack_data.filename,
        "line":       stack_data.lineno,
        "code":       stack_data.code_context[0].strip()
      }
      
      name_of_module_that_was_called = (actual_function.__module__ + ".py").split(".")[-2] + ".py"
      name_of_module_that_made_the_call = os.path.basename(calling_call_metadata["file_path"])
      
      #print("\t" + str(calling_call_metadata["line"]) + ": " + calling_call_metadata["code"])
      
      self._sequence_diagram.add(node_name_from=name_of_module_that_made_the_call,
                                 node_name_to=name_of_module_that_was_called, 
                                 label=str(calling_call_metadata["line"]) + ": " + calling_call_metadata["code"])
      
      actual_function_result = actual_function(*args, **kwargs)
      return actual_function_result

  def __exit__(self, exc_type, exc_value, traceback):
    self._sequence_diagram.draw(first_node_name=self._top_file_name,
                                title="sequence diagram")
    

class _UmletSequenceDiagram:
    DEFAULT_UMLET_EXE_INSTALL_PATH = r'"C:\Program Files (x86)\Umlet\Umlet.exe"'
    ABSOLUTE_PATH_TO_LOCAL_UMLET_EXE = os.path.join(THIS_FILES_DIRECTORY_PATH, r"umlet-standalone-14.3.0\Umlet\Umlet.exe")

    #ASCII_NUMBER_FOR_A = 97
    #generate_unique_character = (chr(_UmletSequenceDiagram.ASCII_NUMBER_FOR_A + i) for i in range(27))
    _generate_unique_character = lambda: ''.join([random.choice(string.ascii_letters) for n in range(32)])
    _generate_unique_number = (i for i in range(5000))

    def __init__(self):
        self._node_names_to_instances = {}
        self._node_names_to_sequence_id = {}
        self._node_name_to_id = {}
        self._diagram_xml_line_list = []

    def add(self, node_name_from, node_name_to, label):
      if node_name_to not in self._node_names_to_instances:
        self._node_names_to_instances[node_name_to] = object()
      if node_name_from not in self._node_names_to_instances:
        self._node_names_to_instances[node_name_from] = object()

      if node_name_to not in self._node_names_to_sequence_id:
        self._node_names_to_sequence_id[node_name_to] = 0
      if node_name_from not in self._node_names_to_sequence_id:
        self._node_names_to_sequence_id[node_name_from] = 0

      self._node_names_to_sequence_id[node_name_to] += 1

      if node_name_to not in self._node_name_to_id:
        self._node_name_to_id[node_name_to] = _UmletSequenceDiagram._generate_unique_character()
      if node_name_from not in self._node_name_to_id:
        self._node_name_to_id[node_name_from] = _UmletSequenceDiagram._generate_unique_character()
    
      #self._node_names_to_instances[node_name_from],
      #self._node_names_to_instances[node_name_to], 

      node_from_id = self._node_name_to_id[node_name_from]
      node_to_id = self._node_name_to_id[node_name_to]

      if node_from_id != node_to_id:
        sequence_id = next(_UmletSequenceDiagram._generate_unique_number)
        self._diagram_xml_line_list.append(f"{node_from_id}.{node_from_id}{sequence_id}->>>{node_to_id} :{label}")
        return

      self._diagram_xml_line_list.append(f"{node_from_id}->>>{node_from_id} + :{label}")
      self._diagram_xml_line_list.append("tick=") # NOTE: for some reason, if you don't "tick=" after a line to self, then the next line is at the same level as the line to self
        
    def draw(self, first_node_name, title):
        node_names = list(self._node_names_to_instances.keys())
        node_names.remove(first_node_name)
        node_names = [first_node_name] + node_names # NOTE: ensure that "first_node_name" appears on the left of the diagram
        object_string = "".join(["obj=" + x + f"~{self._node_name_to_id[x]}\n" for x in node_names])
        first_node_id = self._node_name_to_id[first_node_name]
        gate_string = f"""gate->>>{first_node_id}.{first_node_id} :capture started"""
        xml_sequence_lines = "\n".join(self._diagram_xml_line_list)
        #print(self._diagram_xml_line_list)
    
        output_uxf_file_path = os.path.join(THIS_FILES_DIRECTORY_PATH, "autogenerated-sequence_diagram.uxf")
        with open(output_uxf_file_path, "wt") as f:
            f.write(f"""<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.2">
  <zoom_level>10</zoom_level>
  <element>
    <id>UMLSequenceAllInOne</id>
    <coordinates>
      <x>150</x>
      <y>190</y>
      <w>740</w>
      <h>410</h>
    </coordinates>
    <panel_attributes>title={title}
autoTick=true
{object_string}
{gate_string}
{xml_sequence_lines}
</panel_attributes>
    <additional_attributes/>
  </element>
</diagram>""")

        umlet_command_to_convert_to_png = f" -action=convert -format=png -filename={output_uxf_file_path}"

        umlet_is_installed = os.path.exists(_UmletSequenceDiagram.DEFAULT_UMLET_EXE_INSTALL_PATH)
        umlet_is_in_same_directory_as_this_file = os.path.exists(_UmletSequenceDiagram.ABSOLUTE_PATH_TO_LOCAL_UMLET_EXE)
        if umlet_is_installed:
            umlet_exe_path = _UmletSequenceDiagram.DEFAULT_UMLET_EXE_INSTALL_PATH
        elif umlet_is_in_same_directory_as_this_file:
            umlet_exe_path = _UmletSequenceDiagram.ABSOLUTE_PATH_TO_LOCAL_UMLET_EXE
        else:
            raise RuntimeError(f'Download Umlet: https://www.umlet.com/download/umlet_14_3/umlet-standalone-14.3.0.zip and unzip it here: "{THIS_FILES_DIRECTORY_PATH}"')
            
        os.system(umlet_exe_path + umlet_command_to_convert_to_png)